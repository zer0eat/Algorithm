# 고층건물_BOJ1027

# input.txt 열기
import sys
sys.stdin = open('input.txt')

# input 받기
N = int(sys.stdin.readline().strip())                               # 빌딩의 수를 input 받고
buliding = list(map(int, sys.stdin.readline().split()))             # 빌딩의 높이를 list로 input 받는다
ans = 0                                                             # 가장 많이 보이는 빌딩의 수를 저장할 변수를 생성한다

for i in range(N):                                                  # 건물 순서를 반복해서
    segment = [0] * N                                               # i번째 건물과의 선분의 길이를 저장할 리스트를 생성한다
    for j in range(N):                                              # 건물 순서를 다시 반복해서
        if i == j:                                                  # i와 j가 같은 건물이라면
            pass                                                    # pass
        elif i < j:                                                 # i 건물보다 오른쪽에 있는 건물이라면
            segment[j] = (buliding[j] - buliding[i]) / (j - i)      # 선분리스트에 i건물과 비교한 선분의 기울기를 저장한다
        elif i > j:                                                 # i 건물보다 왼쪽에 있는 건물이라면
            segment[j] = (buliding[i] - buliding[j]) / (i - j)      # 선분리스트에 i건물과 비교한 선분의 기울기를 저장한다
    else:                                                           # 모든 건물을 비교하여 선분의 기울기가 저장되었다면
        tmp1 = [0, -1000000000, False]                              # tmp1 리스트에 [보이는 건물이 수, 가장 멀리 보이는 건물과의 기울기, 건물을 내려다보면 False 올려다보면 True] 원소를 넣어 생성한다
        for x in range(i+1, N):                                     # i의 오른쪽으로 이동하며 건물과 비교한다
            if tmp1[2] == False:                                    # i보다 높은 건물이 없어 내려다 보는 상태라면
                if buliding[i] < buliding[x]:                       # i건물보다 x건물이 더 높을 때
                    tmp1[2] = True                                  # 앞으로는 건물을 올려다 봐야 옥상이 보이므로 tmp1의 2번째 원소를 True로 바꾸고
                    tmp1[0] += 1                                    # tmp1의 0번째 원소 1 추가하여 보이는 건물의 수를 카운트한다
                    tmp1[1] = segment[x]                            # x건물을 볼 수 있으므로 tmp1의 1번째 원소에 가장 멀리보이는 x건물의 선분의 기울기를 저장한다
                else:                                               # i건물보다 x건물이 더 낮을 때
                    if tmp1[1] < segment[x]:                        # 현재 가장 멀리보이는 빌딩의 선분보다 x건물의 선분의 기울기가 더 크다면 옥상이 보이므로
                        tmp1[0] += 1                                # tmp1의 0번째 원소 1 추가하여 보이는 건물의 수를 카운트한다
                        tmp1[1] = segment[x]                        # x건물을 볼 수 있으므로 tmp1의 1번째 원소에 가장 멀리보이는 x건물의 선분의 기울기를 저장한다
            else:                                                   # i보다 높은 건물이 나와 올려다보는 상태라면
                if tmp1[1] < segment[x]:                            # 현재 가장 멀리보이는 빌딩의 선분보다 x건물의 선분의 기울기가 더 크다면 옥상이 보이므로
                    tmp1[0] += 1                                    # tmp1의 0번째 원소 1 추가하여 보이는 건물의 수를 카운트한다
                    tmp1[1] = segment[x]                            # x건물을 볼 수 있으므로 tmp1의 1번째 원소에 가장 멀리보이는 x건물의 선분의 기울기를 저장한다

        tmp2 = [0, -1000000000, False]                              # cnt 선분 높이 업다운
        for y in range(i-1, -1, -1):                                # i부터 왼쪽으로 이동하며 건물과 비교한다
            if tmp2[2] == False:                                    # i보다 높은 건물이 없어 내려다 보는 상태라면
                if buliding[i] < buliding[y]:                       # i건물보다 y건물이 더 높을 때
                    tmp2[2] = True                                  # 앞으로는 건물을 올려다 봐야 옥상이 보이므로 tmp2의 2번째 원소를 True로 바꾸고
                    tmp2[0] += 1                                    # tmp2의 0번째 원소 1 추가하여 보이는 건물의 수를 카운트한다
                    tmp2[1] = -segment[y]                           # y건물을 볼 수 있으므로 tmp2의 1번째 원소에 가장 멀리보이는 y건물의 선분의 기울기를 저장한다(i건물의 왼쪽으로 탐색할 땐 i건물보다 큰 건물이 음수로 작은건물이 양수로 저장되어 있으므로  - 부호를 붙여준다)
                else:                                               # i건물보다 y건물이 더 낮을 때
                    if tmp2[1] < -segment[y]:                       # 현재 가장 멀리보이는 빌딩의 선분보다 y건물의 선분의 기울기가 더 크다면 옥상이 보이므로
                        tmp2[0] += 1                                # tmp2의 0번째 원소 1 추가하여 보이는 건물의 수를 카운트한다
                        tmp2[1] = -segment[y]                       # y건물을 볼 수 있으므로 tmp2의 1번째 원소에 가장 멀리보이는 y건물의 선분의 기울기를 저장한다
            else:                                                   # i보다 높은 건물이 나와 올려다보는 상태라면
                if tmp2[1] < -segment[y]:                           # 현재 가장 멀리보이는 빌딩의 선분보다 y건물의 선분의 기울기가 더 크다면 옥상이 보이므로
                    tmp2[0] += 1                                    # tmp2의 0번째 원소 1 추가하여 보이는 건물의 수를 카운트한다
                    tmp2[1] = -segment[y]                           # y건물을 볼 수 있으므로 tmp2의 1번째 원소에 가장 멀리보이는 y건물의 선분의 기울기를 저장한다

        if ans < tmp1[0]+tmp2[0]:                                   # i를 기준으로 왼쪽과 오른쪽 건물의 탐색을 모두 마친 후에 ans에 저장된 가장 많이 보이는 건물의 수보다 왼쪽으로 보이는 건물의 수와 오른쪽으로 보이는 건물의 수의 합이 더 크다면
            ans = tmp1[0]+tmp2[0]                                   # ans를 새로운 최대값으로 바꿔준다
else:                                                               # 모든 건물을 반복했을 때
    print(ans)                                                      # 가장 많이 보이는 옥상의 수를 출력한다